{"version":3,"sources":["components/card/card.component.jsx","components/card-list/card-list.component.jsx","components/search-box/search-box.component.jsx","App.js","serviceWorker.js","index.js"],"names":["Card","props","react_default","a","createElement","className","alt","src","concat","monster","id","name","email","CardList","monsters","map","card_component_Card","key","SearchBox","_ref","placeholder","handleChange","type","onChange","App","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","e","setState","searchField","target","value","state","_this2","fetch","then","response","json","users","_this$state","filteredMonsters","filter","toLowerCase","includes","search_box_component_SearchBox","card_list_component_CardList","Component","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"oTAKaA,SAAO,SAACC,GAAD,OAChBC,EAAAC,EAAAC,cAAA,OAAKC,UAAU,kBACXH,EAAAC,EAAAC,cAAA,OAAKE,IAAI,UAAUC,IAAG,wBAAAC,OAA0BP,EAAMQ,QAAQC,GAAxC,4BACtBR,EAAAC,EAAAC,cAAA,cAAMH,EAAMQ,QAAQE,KAApB,KACAT,EAAAC,EAAAC,cAAA,aAAKH,EAAMQ,QAAQG,MAAnB,QCAKC,SAAW,SAACZ,GACrB,OAAQC,EAAAC,EAAAC,cAAA,OAAKC,UAAU,aAKfJ,EAAMa,SAASC,IAAI,SAAAN,GAAO,OAEtBP,EAAAC,EAAAC,cAACY,EAAD,CAAMC,IAAKR,EAAQC,GAAID,QAASA,SCVnCS,SAAY,SAAAC,GAAA,IAAGC,EAAHD,EAAGC,YAAaC,EAAhBF,EAAgBE,aAAhB,OAEvBnB,EAAAC,EAAAC,cAAA,SAEEC,UAAU,SACViB,KAAK,SACLF,YAAaA,EAEbG,SAAUF,MCgDCG,qBArDb,SAAAA,IAAc,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAJ,IAEZC,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAF,GAAAO,KAAAH,QAqBFP,aAAe,SAACW,GACdP,EAAKQ,SAAS,CAAEC,YAAaF,EAAEG,OAAOC,SArBtCX,EAAKY,MAAQ,CAEXvB,SAAU,GAEVoB,YAAa,IAPHT,mFAYM,IAAAa,EAAAV,KAGlBW,MAAM,8CACHC,KAAK,SAAAC,GAAQ,OAAIA,EAASC,SAE1BF,KAAK,SAAAG,GAAK,OAAIL,EAAKL,SAAS,CAAEnB,SAAU6B,uCAUpC,IAAAC,EAE2BhB,KAAKS,MAA/BvB,EAFD8B,EAEC9B,SAAUoB,EAFXU,EAEWV,YACZW,EAAmB/B,EAASgC,OAAO,SAAArC,GAAO,OAC9CA,EAAQE,KAAKoC,cAAcC,SAASd,EAAYa,iBAGlD,OACE7C,EAAAC,EAAAC,cAAA,OAAKC,UAAU,OACbH,EAAAC,EAAAC,cAAA,8BACAF,EAAAC,EAAAC,cAAC6C,EAAD,CACE7B,YAAY,kBAEZC,aAAcO,KAAKP,eAMrBnB,EAAAC,EAAAC,cAAC8C,EAAD,CAAUpC,SAAU+B,YAhDVM,cCGEC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAOxD,EAAAC,EAAAC,cAACuD,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMxB,KAAK,SAAAyB,GACjCA,EAAaC","file":"static/js/main.c78b39bc.chunk.js","sourcesContent":["import React from 'react';\n\nimport './card.styles.css';\n\n//passing individual monsters as props into the card component\nexport const Card = (props) => (\n    <div className='card-container'>\n        <img alt=\"monster\" src={`https://robohash.org/${props.monster.id}?set=set2&size=180x180`} />\n        <h2> {props.monster.name} </h2>\n        <p> {props.monster.email} </p>\n    </div>\n);","import React from 'react';\n\nimport { Card } from '../card/card.component';\n\nimport './card-list.styles.css';\n\n//cardlist functional component i.e one single monster div\n//takes in props which are the parameter we get from our functional component\n//we are also exporting it to App.js (main app file)\nexport const CardList = (props) => {\n    return (<div className='card-list'>\n        {\n            //we are rendering js expressions, so they need to be wrapped in {}\n            //map takes on the first element function as param we pass into it, returns us the return of whatever function passed to it, iterated over every element in the array\n            //keys are used to know which state element/html tag has been updated\n            props.monsters.map(monster => (\n                //passing a monster in the card component\n                <Card key={monster.id} monster={monster}/>\n            ))}\n    </div>);\n};","import React from \"react\";\n\nimport \"./search-box.styles.css\";\n\n//functional components does not have access to states or internal states, life cycle methods, because they dont have access to the constructor()\n//functional components just gets some props and then return some html\n//functional component for our search box with dynamic props, then export it so that you can use it elsewhere\nexport const SearchBox = ({ placeholder, handleChange }) => (\n  /* search field input */\n  <input\n    //class name for css styling\n    className=\"search\"\n    type=\"search\"\n    placeholder={placeholder}\n    //this syntheticEvent (syntheticEvent is a fake event that pretends an event is a DOM event,when there is a change in the DOM, React intercept is and say something change let me go tell my app something just happened),it is used to get the value of what is type in the searchfield...e is the event received\n    onChange={handleChange}\n  />\n);\n","import React, { Component } from \"react\";\n\nimport { CardList } from \"./components/card-list/card-list.component\";\n\nimport { SearchBox } from \"./components/search-box/search-box.component\";\n\nimport \"./App.css\";\n\n//class App extends React.Component... means, I want and want to add on to whatever functionality that is built in a React class\nclass App extends Component {\n  constructor() {\n    //super() extends the functionality from our Component class which we get from React\n    super();\n    this.state = {\n      //this holds our monsters names\n      monsters: [],\n      //storing what the users type in the search box into our state so that we can use it for filter\n      searchField: \"\"\n    };\n  }\n\n  //componentDidMount life cycle method allows React to display through what we type in the  {} or put or mount our component on the DOM page\n  componentDidMount() {\n    //fetch makes an api request and return a promise\n    //and the promise gives us a actual response of the body of our response in a json format\n    fetch(\"https://jsonplaceholder.typicode.com/users\")\n      .then(response => response.json())\n      //the response gotten updates our monsters state using the setState() with the new array of users\n      .then(users => this.setState({ monsters: users }));\n  }\n\n  //class method for handleChange event in the search box\n  //we are using arrow function to automatically bind the this. context to the place where they are defined in the first place (App class Component...root)\n  handleChange = (e) => {\n    this.setState({ searchField: e.target.value });\n  }\n\n  //Rerender or reloads our App when there is a change in state\n  render() {\n    //here we filter the monster state with the value we got from the searchField using destructuring (pulling properties off an object)\n    const { monsters, searchField } = this.state;\n    const filteredMonsters = monsters.filter(monster =>\n      monster.name.toLowerCase().includes(searchField.toLowerCase())\n    );\n\n    return (\n      <div className=\"App\">\n        <h1>Monsters Rolodex</h1>\n        <SearchBox\n          placeholder=\"Search monsters\"\n          //this. is a keyword that references the context in which its being invoked\n          handleChange={this.handleChange}\n        />\n        {/* prop is the object of any property you write as attribute in any component\n        props have children, children are what we place inside or in between our components tags or element\n        Passing our monsters as props or attribute.\n        States are passed down to components as props or attributes */}\n        <CardList monsters={filteredMonsters} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}